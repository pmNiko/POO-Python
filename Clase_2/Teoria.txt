
   """ Herencia """

Habiamos visto
/*******
2 pilares de la POO 
  -> Encapsulaci贸n: esta propiedad asegura que el estado interno de un objeto solo puede ser
     modificado por si mismo mediante metodos predefinidos. De esta manera el objeto expondra 
     hacia el exterior solo la informaci贸n necesaria que desea comunicar. 
      Pensemos en un auto, este le comunica al resto que va realizar un giro, pero no expone 
     sus componentes internos, de esta manera solo provee la informaci贸n necesaria para poder
     comunicarse con el resto. 
  
  -> Abstracci贸n este principio hace referencia a que la clase debe representar las caracter铆sticas
     de la entidad hacia el mundo exterior, pero ocultando la complejidad que lleva aparejada. Es 
     decir abstrae la complejidad, brindando una serie de atributos y metodos que podemos utilizar 
     sin preocuparnos por su implementaci贸n, este principio viene de la mano al principio de 
     Encapsulaci贸n.
*******/

Vamos a ver los otros dos pilares de la POO

  -> Herencia: esta es una de las caracteristicas mas potentes de este paradigma ya que permite 
     realizar relaciones jerarquicas entre clases, de forma que atributos y metodos seran heredados
     por las subclases, esto fomenta la reutilizaci贸n de codigo.
     Asi podemos ver que la clase Animal tiene su estado y comportamiento, entonces podemos crear una 
     subclase Perro la cual heredar谩 atributos y metodos de la clase Animal.

Veamos la clase Animal y como puede heredar la clase Gato


____________________________________________________________________________________________________

   Qu茅 es una clase abstracta

      Las clases abstractas, como su nombre lo indica, son algo abstracto, 
      no representan algo espec铆fico y las podemos usar para crear otras clases. 
      No pueden ser instanciadas, por lo que no podemos crear nuevos objetos con ellas.
      Solamente se pueden usar para construir subclases. 
      Permitiendo as铆 tener una 煤nica implementaci贸n de los m茅todos compartidos, evitando la duplicaci贸n de c贸digo.

      Resumiendo, las clases abstractas define una interfaz com煤n para las subclases. 
      Proporciona atributos y m茅todos comunes para todas las subclases evitando as铆 la necesidad de duplicar c贸digo. 
      Imponiendo adem谩s lo m茅todos que deber ser implementados para evitar inconsistencias entre las subclases.

   Creaci贸n de clases abstractas en Python

      Para poder crear clases abstractas en Python es necesario importar la clase ABC y el decorador abstractmethod 
      del modulo abc (Abstract Base Classes). Un m贸dulo que se encuentra en la librer铆a est谩ndar del lenguaje, 
      por lo que no es necesario instalar. 
      As铆 para definir una clase privada solamente se tiene que crear una clase heredada de ABC con un m茅todo abstracto.

   from abc import ABC, abstractmethod

      class Animal(ABC):
         @abstractmethod
         def mover(self):
            pass

   
   Ahora si se intenta crear una instancia de la clase animal, 
   Python no lo permitir谩 indicando que no es posible. 
   Es importante notar que que si la clase no hereda de ABC o contiene por lo menos un m茅todo abstracto, 
   Python permitir谩 instancias las clases.


   Por otro lado, desde los m茅todos de las subclases podemos llamar a las implementaciones de la clase abstracta 
   con el comando super() seguido del nombre del m茅todo.

      class Animal(ABC):
         @abstractmethod
         def mover(self):
            pass
         
         @abstractmethod
         def comer(self):
            print('Animal come')

        
      class Gato(Animal):
         def mover(self):
            print('Mover gato')
            
            
         def comer(self):
            super().comer()
            print('Gato come')
            

      g = Gato()
      g.mover()
      g.comer()

Conclusiones
   En esta entrada se ha visto c贸mo se pueden usar el patr贸n de clase abstracta en Python. 
   Un patr贸n que es clave en programaci贸n orientada a objetos para evitar la repetici贸n de c贸digo, 
   centralizando las funcionalidades comunes en una clase que sirve de plantilla para las clases hijas.


____________________________________________________________________________________________________

  """ Polimorfismo """

   La palabra Polimorfismo viene del griego "polys" que significa muchos
   y "morfo" que refiere a forma, su conjunto define la cualidad de 
   tener multiples formas.

   En POO, este concepto hace referencia a que varios objetos de clases distintas
   compartiendo una superclase en com煤n, pueden definir un mismo metodo de 
   maneras distintas. 

     Ejercicio:
      Clases:
         Suma
         Reata
         Multiplicacion
         Division

      Clase Abstracta OperacionMatematica
        metodo abstracto:
             operar()
         
      Script operaciones_matematica.py

____________________________________________________________________________________________________
Vemaos la implementacion de la clase mi_fecha
   la clase MiFecha:
      - (==, <, <=, >=, >)
      - esta entre "una_fecha" y "otra_fecha"


Veamos la implementaci贸n de numero.py para el cual vamos a definir el mismo protocolo que realizamos en 
   La clase Numero: 
      - (==, <, <=, >=, >)
      - esta entre "un_numero" y "otro_numero"

Magnitudes lineales
    Cualquier magnitud que se pueda comparar linealmente puede utilizar la misma implementacion. 
    Solo necesita definir dos conceptos:
      -> igualdad
      -> ser menor a otra magnitud de mi clase

Pongamos en pr谩ctica.
Modelemos la clase MagnitudLineal 

   Protocolo:
       <= otra_magnitud   # metodo concreto
       > otra_magnitud    # metodo concreto
       >= otra_magnitud   # metodo concreto
       entre(una_magnitud, otra_magnitud)   # metodo concreto


       == otra_magnitud    # metodo abstracto
       <  otra_magnitud    # metodo abstracto

Por ultimo en MiFecha comentemos los metodos: "__le__" - "__ge__" - "__ge__" - "entreDosFechas"
Podemos ver que al correr los test nos acusan error porque no encuentra 
los metodos.

Ahora importemos la clase MagnitudLineal y hagamos que MiFecha herede de ella.
Al correr los test И estos pasan correctamente.
Excepto los del mensaje entreDosFechas puesto que no encuentra esa definici贸n de mensaje.
podemos hacer dos cosas:
   -> Envolver el mensaje de la superclase 
         ejemplo: 
                def entreDosFechas(self, fecha_inicio, fecha_fin):
                     """ Devuelve un booleano si se encuentra entre las
                           dos fechas que recibe como parametro."""
                     return super().entre(fecha_inicio, fecha_fin)

   -> Cambiar los nombres en el setup de test 

Realicemos el mismo procedimiento con Numero. 
corran los test.

Si ahora modelaramos la clase Character sabiendo que cada caracter tiene un valor numerico ASCII
   Fuente: https://elcodigoascii.com.ar/

   En python contamos con dos funciones o metodos 
      -> ord('a')   # devuelve el valor ASCII
      >>> 97 

      -> chr(97)    # devuelve el caracter correspondiente
      >>> 'a'

Modelemos ahora Character haciendolo extender de MagnitudLineal y definamos los dos metodos
abstractos: 
   "__eq__"    y    "__lt__"

Realicen los test que validen su comportamiento.
 


