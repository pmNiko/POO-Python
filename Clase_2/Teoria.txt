
   """ Herencia """

  -> Herencia:
      Nos permite realizar relaciones jerarquicas entre clases, 
      de forma que atributos y metodos seran heredados por las subclases, 
      esto fomenta la reutilizaciÃ³n de codigo.

     Asi podemos ver que la clase Animal tiene su estado y comportamiento, entonces podemos crear una 
     subclase Perro la cual heredarÃ¡ atributos y metodos de la clase Animal.

Veamos la clase Animal y como puede heredar la clase Gato


____________________________________________________________________________________________________

   QuÃ© es una clase abstracta

      âœ… Las clases abstractas no representan algo especÃ­fico y las podemos usar para crear otras clases. 

      âœ… No pueden ser instanciadas, por lo que no podemos crear nuevos objetos con ellas.

      âœ… Solamente se pueden usar para construir subclases. 

      ğŸ“š Resumiendo, las clases abstractas define una interfaz comÃºn para las subclases. 
      ğŸ“š Imponiendo ademÃ¡s lo mÃ©todos que deber ser implementados para evitar inconsistencias entre las subclases.


   CreaciÃ³n de clases abstractas en Python

      Para poder crear clases abstractas en Python es necesario importar la clase "ABC" y el decorador "abstractmethod" 
      del modulo "abc" (Abstract Base Classes). 

   from abc import ABC, abstractmethod

      class Animal(ABC):
         @abstractmethod
         def mover(self):
            pass

   
   Ahora si se intenta crear una instancia de la clase animal, Python no lo permitirÃ¡ indicando que no es posible. 

   Por otro lado, desde los mÃ©todos de las subclases podemos llamar a las implementaciones de la clase abstracta 
   con el metodo super() seguido del nombre del mÃ©todo.

      class Animal(ABC):

         @abstractmethod
         def mover(self):
            pass         
         
         def comer(self):
            print('Animal come')

        
      class Gato(Animal):
         def mover(self):
            print('Mover gato')
            
            
         def comer(self):
            super().comer()
            print('Gato come')
            

      g = Gato()
      g.mover()
      g.comer()

Conclusiones
   En esta entrada se ha visto cÃ³mo se pueden usar el patrÃ³n de clase abstracta en Python. 
   Un patrÃ³n que es clave en programaciÃ³n orientada a objetos para evitar la repeticiÃ³n de cÃ³digo, 
   centralizando las funcionalidades comunes en una clase que sirve de base para las clases hijas.


____________________________________________________________________________________________________

  """ Polimorfismo """

   La palabra Polimorfismo viene del griego "polys" que significa muchos
   y "morfo" que refiere a forma, su conjunto define la cualidad de 
   tener multiples formas.

   Dos objetos son polimorficos con respecto a un mensaje si pueden entender ese mensaje, 
   aÃºn cuando reaccionen de manera diferente al mismo.

     Ejercicio:
      Clases:
         Suma
         Resta
         Multiplicacion
         Division

      Clase Abstracta OperacionMatematica
        metodo abstracto:
            ğŸ‘‰ğŸ» operar()
         
      Script operaciones_matematica.py

   Como podemos ver las cuatro clases implementan el metodo operar() aunque sus implementaciones
   sean distintas.

____________________________________________________________________________________________________
   Overloading

   Veamos el objeto Fecha
____________________________________________________________________________________________________

Magnitudes lineales
   ğŸ‘‰ğŸ» Cualquier magnitud que se pueda comparar linealmente puede utilizar la misma implementacion. 
   ğŸ‘‰ğŸ» Solo necesita definir dos conceptos:
      -> igualdad                                     ==
      -> ser menor a otra magnitud de mi clase        <
      
Vemaos la implementacion de la clase mi_fecha
   la clase MiFecha:
      - (==, <, <=, >=, >)
      - esta entre "una_fecha" y "otra_fecha"


Veamos la implementaciÃ³n de numero.py para el cual vamos a definir el mismo protocolo que realizamos en 
   La clase Numero: 
      - (==, <, <=, >=, >)
      - esta entre "un_numero" y "otro_numero"



Pongamos en prÃ¡ctica.
Modelemos la clase MagnitudLineal 

   Protocolo:
      ğŸ‘‰ğŸ» <= otra_magnitud                       # metodo concreto
      ğŸ‘‰ğŸ» > otra_magnitud                        # metodo concreto
      ğŸ‘‰ğŸ» >= otra_magnitud                       # metodo concreto
      ğŸ‘‰ğŸ» entre(una_magnitud, otra_magnitud)     # metodo concreto


      ğŸ‘‰ğŸ» == otra_magnitud                       # metodo abstracto
      ğŸ‘‰ğŸ» <  otra_magnitud                       # metodo abstracto

Por ultimo en MiFecha comentemos los metodos: "__le__" - "__ge__" - "__ge__" - "entreDosFechas"
Podemos ver que al correr los test nos acusan error porque no encuentra 
los metodos.

 - Ahora importemos la clase MagnitudLineal y hagamos que MiFecha herede de ella.
 - Al correr los test ğŸ§ª estos pasan correctamente âœ….

Excepto los del mensaje "entreDosFechas" puesto que no encuentra esa definiciÃ³n de mensaje.
podemos hacer dos cosas:
   -> Envolver el mensaje de la superclase 
         ejemplo: 
                def entreDosFechas(self, fecha_inicio, fecha_fin):
                     """ Devuelve un booleano si se encuentra entre las
                           dos fechas que recibe como parametro."""
                     return super().entre(fecha_inicio, fecha_fin)

   -> Cambiar los nombres en la suite de test 

Realicemos el mismo procedimiento con Numero. 
corran los test.

Si ahora modelaramos la clase Character sabiendo que cada caracter tiene un valor numerico ASCII
   Fuente: https://elcodigoascii.com.ar/

   En python contamos con dos funciones o metodos 
      -> ord('a')   # devuelve el valor ASCII
      >>> 97 

      -> chr(97)    # devuelve el caracter correspondiente
      >>> 'a'

Modelemos ahora Character haciendolo extender de MagnitudLineal y definamos los dos metodos
abstractos: 
   "__eq__"    y    "__lt__"

Realicen los test que validen su comportamiento.

Los metodos concretos de la clase Abstracta se resulven en base a los metodos concretos de las
subclases.


 


